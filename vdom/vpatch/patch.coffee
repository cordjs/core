define [
  './domIndex'
  './patchOp'
  './PatchScript'
  'cord!utils/Future'
  'underscore'
], (domIndex, patchOp, PatchScript, Promise, _) ->

  patch = (rootNode, patches, widgetInfo) ->
    ###
    Updates the given DOM node according to the given virtual-dom patch
    @param {Node} rootNode - DOM node to which apply the patch
    @param {Object} patches - special object containing old VNode and patch-lists by node indexes
    @param {Object} widgetInfo - additional info about widget infrastructure
                                 * widget - the widget instance that is patched
                                 * widgetRepo - widget repository service
                                 * widgetFactory - widget factory service
    @return {Promise.<Node>} updated root node
    ###
    ownerDocument = rootNode.ownerDocument
    renderOptions =
      patch: createPatchScriptRec
      widgetInfo: widgetInfo
    renderOptions.document = ownerDocument  if ownerDocument != document

    createPatchScriptRec(patches, renderOptions).then (script) ->
      script.run(rootNode)



  createPatchScriptRec = (patches, renderOptions) ->
    ###
    Creates a new patch-script for the given patches structure generated by vdom diff algorithm
    @param {Object} patches - special object containing old VNode and patch-lists by node indexes
    @param {Object} renderOptions - additional information need to be provided for some of patch commands
    @return {Promise.<PatchScript>} patch-script - list of commands to be executed against DOM to update it
    ###
    resultScript = new PatchScript

    indices = patchIndices(patches)
    return Promise.resolved(resultScript)  if indices.length == 0

    resultScript.createDomIndex(patches.a, indices)

    promises =
      for nodeIndex in indices
        createPatchScriptForNode(nodeIndex, patches[nodeIndex], renderOptions)
    Promise.all(promises).then (subScripts) ->
      # forking subscript is necessary to maintain the exact order of execution of the patch commands
      # due to asynchronous process of collecting
      resultScript.runSubScript(script) for script in subScripts
      resultScript


  createPatchScriptForNode = (nodeIndex, patchList, renderOptions) ->
    ###
    Creates and returns a new patch-script with commands for patching the given node according to the patch-list.
    @param {PatchScript} patchScript - the patch-script that should be fulfilled with DOM mutation commands
    @param {number} nodeIndex - index of the currently processed DOM node in previously generated DOM-index array
    @param {VPatch|Array.<VPatch>} patchList - list of patches generated by vdom diff algorithm
    @param {Object} renderOptions - additional information need to be provided for some of patch commands
    @return {Promise.<PatchScript>}
    ###
    resultScript = new PatchScript
    resultScript.checkDomNode(nodeIndex)
    if _.isArray(patchList)
      promises =
        for patch in patchList
          patchOp(patch, resultScript.createSubScript(), renderOptions)
      Promise.all(promises).then -> resultScript
    else
      Promise.try ->
        patchOp(patchList, resultScript, renderOptions)


  patchIndices = (patches) ->
    indices = []
    for key of patches
      indices.push(Number(key))  if key != 'a'
    indices


  patch
